# 原生实现折线图

## 一、代码实现

```html
<!doctype html>
<html>

	<head>
		<meta charset="utf-8">
		<title></title>
		<meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" />
		<link href="css/mui.css" rel="stylesheet" />
	</head>

	<body>
		<script src="js/mui.js"></script>
		<script type="text/javascript">
			mui.init()
		</script>
		<header class="mui-bar mui-bar-nav">
			<h1 class="mui-title">折线图</h1>
		</header>
		<div class="mui-content">
			<canvas id="canvas" width="400" height="250"></canvas>
			
			<script type="text/javascript">
				let resdata
				let total
				mui.ajax('http://127.0.0.1:10001/api/carInfo', {
					type: 'GET',
					success: function(e){
						console.log(e.data)
						resdata = e.data
						
						total = resdata.reduce((a, b)=>{
							if(a[b.carNumberType]){
								a[b.carNumberType]+=1
							}else{
								a[b.carNumberType]=1
							}
							return a
						}, {})
						console.log(total)
						let cvs = document.getElementById('canvas')
						let ct = cvs.getContext('2d')
						let cvsHeight = cvs.height
						let cvsWidth = cvs.width
						let paddingSize = 50
						let x_value=[], y_value=[]
						for(const [key, value] of Object.entries(total)){
							x_value.push(key)
							y_value.push(value)
						}
						
						ct.beginPath()
						ct.moveTo(paddingSize, paddingSize)  // 移动到y轴顶部起始位置
						ct.lineTo(paddingSize, cvsHeight-paddingSize)  // 绘制y轴
						ct.lineTo(cvsWidth-paddingSize, cvsHeight-paddingSize)  // 绘制x轴
						ct.stroke()  // 路径描边
						
						let y_max = Math.max(...y_value)  // 获取数据中的最大值
						
						// 对最大值向上取整为10的倍数
						var remainder = y_max % 10
						if (remainder !== 0) {
								y_max = y_max + (10 - remainder)
						}
						
						// 设置y轴每一个单位的距离
						let y_step_size = cvsHeight-paddingSize*2
						y_step_size /= 4
						
						
						// 设置字体样式
						ct.font = '14px Arial'
						ct.fillStyle = '#000'
						ct.textAlign = 'center'
						
						// 绘制y轴字体
						for (var i = 0; i < 5; i++) {
							ct.beginPath()
							ct.fillText(y_max/4*(4-i), paddingSize/2, paddingSize+i*y_step_size)
						}
						
						// 设置x轴每一个单位的距离
						let x_step_size = (cvsWidth-padding*2)/y_value.length
						// console.log(x_step_size)
						// console.log(x_value)
						
						// 绘制x轴标签
						for (var i = 0; i <x_value.length; i++) {
							ct.beginPath()
							// console.log(paddingSize + x_step_size*(i+1))
							ct.fillText(x_value[i], paddingSize + x_step_size*(i+1), cvsHeight - paddingSize/2)
						}
						
						// 绘制折线
						ct.beginPath()
						ct.moveTo(paddingSize,cvsHeight-paddingSize)
						for (var i = 0; i < y_value.length; i++) {
							console.log(y_value[i])
							console.log(y_max)
							ct.lineTo(paddingSize+x_step_size*(i+1), cvsHeight-padding*2-(y_value[i]/y_max*(cvsHeight-padding*2))+paddingSize)
							
						}
						ct.strokeStyle = '#1678ff'
						ct.stroke()
						
						// 绘制每个数据对应的端点
						for (var i = 0; i < y_value.length; i++) {
							ct.beginPath()
							ct.moveTo(paddingSize+x_step_size*(i+1), cvsHeight-padding*2-(y_value[i]/y_max*(cvsHeight-padding*2))+paddingSize)
							ct.arc(paddingSize+x_step_size*(i+1), cvsHeight-padding*2-(y_value[i]/y_max*(cvsHeight-padding*2))+paddingSize, 5, 0, 2*Math.PI)
							ct.fillStyle = '#1678ff'
							ct.fill()
						}
						
						// 绘制每个数据的端点处显示的值
						for (var i = 0; i < y_value.length; i++) {
							ct.beginPath()
							ct.fillText(y_value[i],paddingSize+x_step_size*(i+1), cvsHeight-padding*2-(y_value[i]/y_max*(cvsHeight-padding*2))+paddingSize-10)
						}
					}
				})
			</script>
		</div>
	</body>

</html>

```

