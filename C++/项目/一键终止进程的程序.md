`killspft.cpp`

```c++
#include <windows.h>
#include <tchar.h>
#include <strsafe.h>
#include <stdlib.h>
#include <shellapi.h>

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    MSG  msg;
    WNDCLASS wc = {0};
    wc.lpszClassName = _T("killProcess");
    wc.lpfnWndProc = WndProc;
    wc.hInstance = hInstance;
    wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
    wc.hCursor = LoadCursor(0, IDC_ARROW);

    RegisterClass(&wc);
    CreateWindow(wc.lpszClassName, L"进程终止器",
                 WS_OVERLAPPEDWINDOW | WS_VISIBLE,
                 150, 150, 300, 300, 0, 0, hInstance, 0);

    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    return (int)msg.wParam;
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    static HWND hEdit;
    static HWND hButton;
    static HWND hStatic;

    switch (message)
    {
        case WM_CREATE:
            hStatic = CreateWindow(_T("STATIC"), _T("输入PID:"),
                                   WS_CHILD | WS_VISIBLE,
                                   10, 20, 80, 20, hwnd, (HMENU)3, ((LPCREATESTRUCT)lParam)->hInstance, NULL);
            hEdit = CreateWindow(_T("EDIT"), _T(""),
                                 WS_CHILD | WS_VISIBLE | WS_BORDER,
                                 100, 20, 150, 20, hwnd, (HMENU)1, ((LPCREATESTRUCT)lParam)->hInstance, NULL);
            hButton = CreateWindow(_T("BUTTON"), _T("立即终止"),
                                   WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,
                                   80, 50, 100, 20, hwnd, (HMENU)2, ((LPCREATESTRUCT)lParam)->hInstance, NULL);
            break;
        case WM_COMMAND:
            if (LOWORD(wParam) == 2)
            {
                TCHAR szText[16];
                GetWindowText(hEdit, szText, 16);
                int pid = _ttoi(szText);

                TCHAR szCmd[MAX_PATH];
                StringCchPrintf(szCmd, MAX_PATH, _T("/C taskkill /F /PID %d"), pid);

                SHELLEXECUTEINFO sei = { sizeof(sei) };
                sei.lpVerb = _T("open");
                sei.lpFile = _T("cmd.exe");
                sei.lpParameters = szCmd;
                sei.nShow = SW_HIDE;
                if (!ShellExecuteEx(&sei))
                {
                    MessageBox(hwnd, _T("Failed to kill the process"), _T("Error"), MB_OK | MB_ICONERROR);
                }
            }
            break;
        case WM_DESTROY:
            PostQuitMessage(0);
            break;
    }
    return DefWindowProc(hwnd, message, wParam, lParam);
}
```

`CMakeLists.txt`

```c++
cmake_minimum_required(VERSION 3.28)
project(c__)

set(CMAKE_CXX_STANDARD 14)

add_executable(c__
#        src/test1.cpp
        src/systemMAC.cpp)
target_link_libraries(c__ iphlpapi)


project(getmac)
set(CMAKE_CXX_STANDARD 14)
add_executable(getmac

src/test1.cpp)

project(getSystemSoftID)
set(CMAKE_CXX_STANDARD 14)
add_executable(getSystemSoftID

src/systemSoftID.cpp
        src/stdafx.h)
target_link_libraries(getSystemSoftID Advapi32.lib)

project(msgbox)
set(CMAKE_CXX_STANDARD 14)
add_executable(msgbox

src/msgbox.cpp)

# 以下代码是该项目配置-----------------------------------------------------------
    
project(killsoft)
set(CMAKE_CXX_STANDARD 14)
add_definitions(-DUNICODE -D_UNICODE)
if (MINGW)
    set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -Wl,-subsystem,windows")
endif()
add_executable(killsoft

src/killSoft.cpp)
```

